# Задача structures

Откройте файл `structures.py`. В этом файле для вас уже написаны заготовки функций, которые вам предстоит реализовать.

Каждая функция принимает какие-то аргументы, на основе которых вы должны посчитать ответ на соответствующее задание.
Если ответ на задачу равен `x`, вернуть из функции его можно оператором `return x`.

**Совет**: по возможности используйте стандартные функции и возможности языка, такие как срезы массивов, `sum`, `sorted`
, и так далее.

Во всех задачах, в которых параметры &ndash; это `a` и `k`, гарантируется, что `k` целое и не превосходит длины
массива `a`.

### `def kth(a, k)`

Реализуйте поиск `k`-го по величине элемента в массиве `a` и верните этот самый элемент.

### `def head_tail(a, k)`

Верните массив длины `2k`, первые `k` элементов которого &ndash; это первые `k` элементов массива `a`, а оставшиеся `k`
элементов &ndash; это `k` последних элементов массива `a`.

### `def filter_sort(a, c)`

Дан массив строк `a`. Верните отсортированный массив, состоящий из элементов массива `a`, из которых удалили все строки,
в составе которых есть символ `c`. При этом менять сам массив `a` запрещено!

### `def build_dict(keys, values)`

Постройте и верните словарь, в котором ключам из массива `keys` соответствуют значения под тем же индексом из
массива `values`. Гарантируется, что `keys` и `values` одной длины.

### `def compare_contents(a1, a2)`

Проверьте, что набор элементов массива `a1` совпадает с набором элементов `a2` (без учета количества). Если существует
элемент, принадлежащий только одному из массивов, верните `False`, иначе верните `True`.

Можете считать, что все элементы обоих массивов неизменяемые.